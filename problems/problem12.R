# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#   
#   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# 
# Let us list the factors of the first seven triangle numbers:
#   
#   1: 1
# 3: 1,3
# 6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
# 
# What is the value of the first triangle number to have over five hundred divisors?

# instead of actually calculating the number of factors for a number that keeps getting bigger and bigger
# apparently 

nth_triangle <- function(n_divisors) {
  # find the nth triangle with n_divisors or more
  # similar to triangle_n_factors but with loop and 
  # saved previous value
  # uses coprime properties to optimize calculation
  n1_fact <- 2
  x <- 2
  while (T) {
    n2_fact <- n_factors(ifelse((x+ 1)%%2 ==0, (x+1)/2, x + 1))
    n_fact <- n1_fact * n2_fact
    if (n_fact >= n_divisors) 
      {break}
    else {
      x <- x + 1
      n1_fact <- n2_fact
    }
  }
  return(x)
}

n_factors <- function(n) {
  # find number of factors for n
  return(prod(factorize(n)$exponent + 1))
}

factorize <- function(n) {
  # Find factor tree of number
  pf <- primeFactors(n)
  go <- direction(n, pf) # we'll always start on the left most
  pair <- c(pf[go], n/pf[go])
  primes <- pair[1]
  while (TRUE) {
    if (all(pair %in% pf) == T | pair[2] == 1) {
      primes <- c(primes, pair[2])
      break
      
    }
    reduced_n <- pair[!(pair %in% pf)]
    go <- direction(reduced_n, pf)
    pair <- c(pf[go], reduced_n/pf[go])
    primes <- c(primes, pair[1])
    
  }
  primes <- as.data.frame(table(primes))
  names(primes) <- c('prime_n', 'exponent')
  primes <- primes[primes$prime_n != 1,]
  
  return(primes)
}

direction <- function(n, prime_factors, FUN=max) {
  # Return the index of the prime factor to reduce n
  # right now gives the left most option in the vector
  go <- n %% prime_factors == 0
  return(FUN(which(go == T)))
}

triangle_n_factors <- function(n) {
  # find the number of factors for the nth triangle number
  if (n %% 2 == 0) {n1 <- n/2; n2 <- n+1} else {n1<- n; n2<- (n+1)/2}
  n1 <- prod(factorize(n1)$exponent + 1)
  n2 <- prod(factorize(n2)$exponent + 1)
  n_factors <- n1*n2
  return(n_factors)
}

# Second Attempt
# What about finding prime factors and iterating through possible exponent combinations to find x?

# First attempt Didn't work
find_triangle_n <- function(n_factors, i=2) {
  # Find the first triangle number with a given number of 
  # factors denoted by n_factors
  n_fact <- 1
  points <- NULL
  while (TRUE) {
    triangle <- triangle_n(i)
    n_fact <- length(factors(triangle))
    cat('\n', i, 'Factors:', n_fact)
    flush.console()
    points <- c(points, n_fact)
    if (n_fact >= n_factors) break
    i <- i + 1
    
  }
  cat('\n')
  return(i)
}

triangle_n <- function(n) {
  # Return the nth triangle number
  return((n*(n+1))/2)
}



factors <- function(n) {
  # find all factors of a given number
  # which will involve some multiple of it's
  # prime factors
  pf <- primeFactors(n)
  
  # using the same logic of Erosthenes to re-generate
  # all other factors that are multiples of the primes
  # except we'll include them instead of eliminating them
  factors <- c(1, pf, n)
  for (i in pf) {
    if (n/i > i^2) {
      factors <- c(factors, seq(i^2, n/i, by=i))
    }
  }
  factors <- unique(factors[n %% factors == 0])
  all_factors <- unique(c(factors, n/factors))
  return(all_factors[order(all_factors)])
}


primeFactors <- function(n) {
  # Find prime factors of a given number
  # using erosthenes method
  primes <- sieve(n)
  return(primes[n %% primes == 0])
}

sieve <- function(n) {
  # a range of numbers from 1:n 
  # determine which are prime
  if (n > 3) {
    prime <- c(F, rep(T, n-1))
    for (i in 2:ceiling(sqrt(n))) {
      if (prime[i] == T & i^2 <= n) {
        prime[seq(i^2, n, by=i)] <- F
      }
    }
    return(c(1:n)[prime])
  } 
  # some verification for the small numbers. 
  else if (n == 1) {
    return(c())
  }
  else {
    ifelse(n==3, return(c(2,3)), return(2))
  }
  
}

# this would take forever
#cat("Brute Force:\n")
#print(system.time(bf <- find_triangle_n(500)))
#cat('nth triangle:', bf, 'value:', triangle_n(bf),'\n')

cat('Coprime Optimization:\n')
print(system.time(co <- nth_triangle(500)))
cat('nth triangle:', co, 'value:', triangle_n(co))


